<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>immer test</title>

    <style>
        .viewports{
            position: relative;
        }
        .viewports>canvas,
        .viewports>svg{
            position: absolute;
            top: 0;
            left:0;
            border: 1px solid black;
        }
        .viewports>canvas{
            pointer-events: none;
        }
        </style>
	<script type="importmap">
		{
			"imports": {
                "react-dom": "https://cdn.jsdelivr.net/npm/react-dom@18.2.0/+esm",
                "react": "https://cdn.jsdelivr.net/npm/react@18.2.0/+esm",
                "gl-matrix": "https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/+esm",
				"regl": "https://cdn.jsdelivr.net/npm/regl@2.1/+esm",
				"lodash": "https://cdn.jsdelivr.net/npm/lodash@4.17.21/+esm",
				"immer": "https://cdn.jsdelivr.net/npm/immer@10.1.1/+esm",
                "immutable": "https://cdn.jsdelivr.net/npm/immutable@5.0.0-beta.5/+esm"
			}
		}
	</script>
</head>

<body>
	<main id="main">
		<div id="root">
		</div>
	</main>
	<script type="module">
        import React from "react";
        import ReactDOM from "react-dom";
        import {produce} from "immer";
        import createREGL from "regl"
        import Manipulator from "./UI/Manipulator.js"
        import {vec2} from "gl-matrix"
        import _ from "lodash"


/**
 * draw Scene to SignedDistanceField FBO
 * @param {FBO} framebuffer - The OUTPUT framebuffer to render SDF scene
 * @param {Array} circleData - circleData as array of circles eg.: [[centerX, centerY, radius], ...]
 * @param {Array} outputResolution [width, height] - the output resolution of the framebuffer
 */
function drawSceneToSDF(regl, {
    framebuffer,
    circleData,
    outputResolution
})
{
    regl({...QUAD,
        vert: PASS_THROUGH_VERTEX_SHADER,
        framebuffer: framebuffer,
        depth: { enable: false },
        uniforms:{
            outputResolution: outputResolution,
            circleData: circleData.flat(),
            circleCount: circleData.length
        },
        frag:`precision mediump float;
        #define e 2.71828
        #define PI 3.14159
        #define MAX_CIRCLES 10

        uniform vec3 circleData[MAX_CIRCLES];
        uniform float circleCount;
        uniform vec2 outputResolution;

        vec2 flip(vec2 pos)
        {
            return pos*vec2(1.0,-1.0)+vec2(0.0,outputResolution.y);
        }

        float cosh(float x) {
            return (exp(x) + exp(-x)) / 2.0;
        }
        
        float sinh(float x) {
            return (exp(x) - exp(-x)) / 2.0;
        }

        float tanh(float x) {
            return (exp(x) - exp(-x)) / (exp(x) + exp(-x));
        }

        float atanh(float x) {
            return 0.5 * log((1.0 + x) / (1.0 - x));
        }

        vec2 translate(vec2 samplePosition, vec2 offset){
            return samplePosition - offset;
        }

        float rectangle(vec2 samplePosition, vec2 halfSize){
            vec2 componentWiseEdgeDistance = abs(samplePosition) - halfSize;
            float outsideDistance = length(max(componentWiseEdgeDistance, 0.0));
            float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0.0);
            return outsideDistance + insideDistance;
        }

        float circle(vec2 samplePosition, float radius)
        {
            float d = length(samplePosition);
            return length(samplePosition)-radius;
        }

        vec2 rotate(vec2 samplePosition, float angle_in_degrees){
            float angle_in_radians = angle_in_degrees/180.0 * PI * -1.0;
            float sine = sin(angle_in_radians);
            float cosine = cos(angle_in_radians);
            return vec2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x);
        }

        float intersectSDF(float A, float B)
        {
            return max(A, B);
        }

        float unionSDF(float A, float B)
        {
            return min(A, B); 
        }

        float scene(vec2 sceneCoord)
        {
            // collect all circles
            float sceneDistance = 9999.0;
            for(int i=0;i<1;i++)
            {
                vec2 pos = circleData[i].xy;
                float r = circleData[i].z;
                float circleDistance = circle(translate(sceneCoord, pos), r);
                sceneDistance = unionSDF(circleDistance, sceneDistance);
            }
            return sceneDistance; 
        }

        void main()
        {   
            float d = scene(flip(gl_FragCoord.xy));
            // d = abs(d);
            gl_FragColor = vec4(d,d,d,1.0);
        }`
    })();
}

/**
 * Intersect rays with an sdf
 * @param {FBO} framebuffer - The OUTPUT framebuffer to render HitPoint as data vec4(pos, normal)
 * @param {Texture} rayDataTexture - Rays encoded into a texture as data vec4(pos.xy, dir.xy)
 * @param {Texture} sdfTexture - The scene encoded to a signed distance field.
 */
function intersectRaysWithSDF(regl, {
    framebuffer, 
    outputResolution,
    rayDataTexture, 
    sdfTexture,
})
{
    regl({...QUAD, vert:PASS_THROUGH_VERTEX_SHADER,
        framebuffer: framebuffer,
        uniforms:{
            outputResolution: outputResolution,
            rayDataTexture: rayDataTexture,
            dataResolution: [rayDataTexture.width, rayDataTexture.height],
            sdfTexture: sdfTexture,
            sdfResolution: [sdfTexture.width, sdfTexture.height]
        },
        frag:`precision mediump float;
        uniform sampler2D rayDataTexture;
        uniform sampler2D sdfTexture;
        uniform vec2 dataResolution;
        uniform vec2 outputResolution;

        #define MAX_RAYMARCH_STEPS 9
        #define MIN_HIT_DISTANCE 1.0
        #define MAX_TRACE_DISTANCE 250.0

        struct Ray{
            vec2 pos;
            vec2 dir;
        };

        struct HitPoint{
            vec2 pos;
            vec2 normal;
        };

        HitPoint rayMarch(Ray ray, sampler2D sdfTexture)
        {
            vec2 pos = ray.pos;
            float totalDistanceTraveled = 0.0;
            for(int i=0; i<MAX_RAYMARCH_STEPS; i++)
            {
                vec2 texCoord = pos/outputResolution;
                float currentDistance = texture2D(sdfTexture, texCoord).r;
                totalDistanceTraveled+=currentDistance;
                if(totalDistanceTraveled>MAX_TRACE_DISTANCE){
                    ray.dir = normalize(ray.dir) * MAX_TRACE_DISTANCE;
                    return HitPoint(ray.pos+ray.dir, vec2(1.0,1.0));
                }
                if(currentDistance<1.0)
                {
                    ray.dir = normalize(ray.dir)*distance(pos, ray.pos);
                    return HitPoint(ray.pos+ray.dir, vec2(1.0,1.0));
                }
                pos+=normalize(ray.dir)*currentDistance;
            }

            ray.dir = normalize(ray.dir) * MAX_TRACE_DISTANCE;
            return HitPoint(ray.pos+ray.dir, vec2(10.0,10.0));
        }

        void main()
        {
            // float rayIdx = gl_FragCoord.y*dataResolution.x+gl_FragCoord.y;
            // unpack ray from data texture
            vec2 texCoord = gl_FragCoord.xy / dataResolution;
            vec4 rayData = texture2D(rayDataTexture, texCoord);
            Ray initialRay = Ray(rayData.xy, rayData.zw);

            // intersect ray with signed distance field
            HitPoint hitPoint = rayMarch(initialRay, sdfTexture);

            // output hitData
            gl_FragColor = vec4(hitPoint.pos, hitPoint.normal);
        }`
    })();
}

/**
* Draw rays based on rayDataTexture and hitDataTexture
* 
* @param {Texture} params.rayDataTexture - Texture containing ray data in vec4(pos, dir).
* @param {Texture} params.hitDataTexture - Texture containing hit data in vec4(pos, normal).
* @param {[Array]} params.outputResolution - Resolution of the output [width, height].
*/
function drawRays(regl, {
    rayCount,
    rayDataTexture,
    hitDataTexture,
    outputResolution
}){
    regl({
        // viewport: {x: 0, y: 0, w: 1, h: 1},
        depth: { enable: false },
        primitive: "lines",
        attributes: {
            vertexIdx: _.range(rayCount*2),
        },
        count: rayCount*2,
        uniforms:{
            rayDataTexture: rayDataTexture,
            rayDataResolution: [rayDataTexture.width, rayDataTexture.height],
            hitDataTexture: hitDataTexture,
            hitDataResolution: [hitDataTexture.width, hitDataTexture.height],
            outputResolution: outputResolution
        },
        blend: {
            enable: true,
            func: {
                srcRGB: 'src alpha',
                srcAlpha: 1,
                dstRGB: 'one minus src alpha',
                dstAlpha: 1
            },
            equation: {
                rgb: 'add',
                alpha: 'add'
            },
            color: [0, 0, 0, 0]
        },
        vert: `precision mediump float;
            #define MAX_RAYMARCH_STEPS 9
            #define MIN_HIT_DISTANCE 1.0
            #define MAX_TRACE_DISTANCE 250.0

            attribute float vertexIdx;
            uniform sampler2D rayDataTexture;
            uniform vec2 rayDataResolution;
            uniform sampler2D hitDataTexture;
            uniform vec2 hitDataResolution;
            
            uniform vec2 outputResolution;

            vec2 flip(vec2 pos)
            {
                return pos*vec2(1.0,-1.0)+vec2(0.0,outputResolution.y);
            }

            struct Ray
            {
                vec2 pos;
                vec2 dir;
            };

            struct HitPoint{
                vec2 pos;
                vec2 normal;
            };

            Ray unpackRay(vec4 rayData)
            {
                return Ray(rayData.xy, rayData.zw);
            }

            float modI(float a,float b)
            {
                float m = a-floor((a+0.5)/b)*b;
                return floor(m+0.5);
            }

            vec2 mapToScreen(vec2 P)
            {
                return (P / outputResolution.xy * 2.0 - 1.0);
            }

            void main()
            {
                float lineIdx = floor(vertexIdx/2.0);

                // Sample rayData
                float pixelX = mod(lineIdx, rayDataResolution.x);
                float pixelY = floor(lineIdx / rayDataResolution.x);
                // Calculate the texture coordinates for the center of the texel corresponding to vertexIdx
                vec2 texCoords = (vec2(pixelX, pixelY) + 0.5) / rayDataResolution;
                // Sample the rayData texture at the calculated UV coordinates
                vec4 rayData = texture2D(rayDataTexture, texCoords);

                vec4 hitData = texture2D(hitDataTexture, texCoords);

                // Extract the position and direction from the sampled data
                Ray ray = unpackRay(rayData);
                HitPoint hitPoint = HitPoint(hitData.xy, hitData.zw);

                bool IsLineStartPoint = modI(vertexIdx, 2.0) < 1.0;
                if(IsLineStartPoint){
                    vec2 screenPos = mapToScreen(ray.pos);
                    gl_Position = vec4(screenPos, 0, 1);
                }
                else
                {
                    vec2 screenPos = mapToScreen(hitPoint.pos);
                    gl_Position = vec4(screenPos, 0, 1);
                }

                // draw line vertices
            }`,

        frag:`precision mediump float;
        void main()
        {
            gl_FragColor = vec4(1.0,0.0, 0.0, 0.3);
        }`
    })();
}

// draw Texture to screen
function drawTexture(regl, {
    texture, 
    outputResolution, 
    exposure=1.0,
    framebuffer=null
}={})
{
    regl({...QUAD,
        framebuffer: framebuffer,
        vert: PASS_THROUGH_VERTEX_SHADER,
        depth: { enable: false },
        uniforms:{
            texture: texture,
            outputResolution: outputResolution,
            exposure: exposure
        },
        frag:`precision mediump float;
        uniform sampler2D texture;
        uniform vec2 outputResolution;
        uniform float exposure;
        void main()
        {   
            vec2 UV = gl_FragCoord.xy/outputResolution;
            vec4 color = texture2D(texture, UV);
            gl_FragColor = color*vec4(exposure, exposure, exposure, 1.0);
        }`
    })();
}

        class Lightray{
            constructor(origin, direction){
                this.origin = origin;
                this.direction = direction;
            }
        }

        let scene = {
            "ball": {
                pos: {x: 255.0, y:350.0},
                shape: {type: "circle", radius: 50},
                material: "mirror"
            },
            "light": {
                pos: {x: 255, y: 150},
                light: {type: "point"}
            }
        };
        let listeners = [];
        function emitChange() {
            for (let listener of listeners) {
                listener();
            }
        }

        const sceneStore = {
            addEntity(key, entity)
            {
                const updatedScene = produce(scene, draft=>{
                    draft[key]=entity;
                });

                if(scene!=updatedScene){
                    scene=updatedScene;
                    emitChange();
                }
            },

            updateComponent(key, component, newAttributes)
            {
                const updatedScene = produce(scene, draft=>{
                    Object.assign(draft[key][component], newAttributes);
                });

                if(scene!=updatedScene){
                    scene=updatedScene;
                    emitChange();
                }
            },

            nudgeShape(key)
            {
                console.log("toggle shape", key)

                const updatedScene = produce(scene, draft=>{
                    draft[key]["shape"]["Cx"]+=Math.random()*10-5;
                    draft[key]["shape"]["Cy"]+=Math.random()*10-5;
                });
                
                if(scene!=updatedScene){
                    scene=updatedScene;
                    emitChange();
                }
            },

            removeEntity(key)
            {

            },

            subscribe(listener) 
            {
                listeners = [...listeners, listener];
                return () => {
                    listeners = listeners.filter(l => l !== listener);
                };
            },

            getSnapshot() {
                return scene;
            }
        }

        const h = React.createElement;

        function Outliner({})
        {
            const scene = React.useSyncExternalStore(sceneStore.subscribe, sceneStore.getSnapshot);
            return h("ul", {}, 
                Object.entries(scene)
                    .filter(([key, entity])=>entity.hasOwnProperty("pos"))
                    .map( ([key, entity])=>{
                    return h("li", null, 
                        `${key}: (${entity.pos.x},${entity.pos.y})`
                    )
                })
            );
        }

        function SVGViewport({width, height, className})
        {
            const scene = React.useSyncExternalStore(sceneStore.subscribe, sceneStore.getSnapshot);

            return h("svg", {width, height, className}, 
                Object.entries(scene).filter(([key, entity])=>entity.hasOwnProperty("shape")).map( ([key, entity])=>{
                    return h(Manipulator, {
                        referenceX: entity.pos.x,
                        referenceY: entity.pos.y,
                        onDrag: e=>sceneStore.updateComponent(key, "pos", {
                            x: e.sceneX+e.referenceOffsetX, 
                            y: e.sceneY+e.referenceOffsetY
                        }),
                    }, 
                        h("circle", {cx: entity.pos.x, cy: entity.pos.y, r:30})
                    )
                }),
                Object.entries(scene)
                    .filter(([key, entity])=>entity.hasOwnProperty("pos") && entity.hasOwnProperty("light"))
                    .map( ([key, entity])=>{
                    return h(Manipulator, {
                        referenceX: entity.pos.x,
                        referenceY: entity.pos.y,
                        onDrag: e=>sceneStore.updateComponent(key, "pos", {
                            x: e.sceneX+e.referenceOffsetX, 
                            y: e.sceneY+e.referenceOffsetY
                        }),
                    }, 
                        h("circle", {cx: entity.pos.x, cy: entity.pos.y, r:10, style:{fill:"orange"}})
                    )
                })
            );
        }

       
        const QUAD = {
            primitive: "triangle fan",
            attributes: {
                position: [
                    [-1,-1],
                    [ 1,-1],
                    [ 1, 1],
                    [-1, 1]
                ],
                uv: [
                    [ 0, 0],
                    [ 1, 0],
                    [ 1, 1],
                    [ 0, 1]
                ]
            },
            count: 4
        };

        const PASS_THROUGH_VERTEX_SHADER = `precision mediump float;
        attribute vec2 position;
        attribute vec2 uv;
        varying vec2 vUV;
        void main()
        {
            vUV = uv;
            gl_Position = vec4(position, 0, 1);
        }`;

        const fragmentPreamble = `precision mediump float;
        #define e 2.71828
        #define PI 3.14159`

        class GLRenderer{
            constructor(canvas)
            {
                this.canvas = canvas;
            }

            initGL()
            {
                this.regl = createREGL({
                    canvas: this.canvas,
                    // pixelRatio: 2.0,
                    attributes: {
                        // width: 1024, heigh: 1024,
                        alpha: true,
                        depth: true,
                        stencil :false,
                        antialias: true,
                        premultipliedAlpha: true,
                        preserveDrawingBuffer: false,
                        preferLowPowerToHighPerformance: false,
                        failIfMajorPerformanceCaveat: false
                    },
                    extensions: ['OES_texture_float', "OES_texture_half_float"]
                });
                const regl = this.regl;

                this.sdfTexture = regl.texture({
                    width: 512, 
                    height: 512,
                    wrap: 'clamp',
                    format: "rgba",
                    type: "float"
                });

                this.sdfFbo = regl.framebuffer({
                    color: this.sdfTexture,
                    depth: false
                });

                this.rayDataTexture = regl.texture({
                    width: 16,
                    height: 16,
                    wrap: 'clamp',
                    min: "nearest", 
                    mag: "nearest",
                    format: "rgba",
                    type: "float",
                });

                this.hitDataTexture = regl.texture({
                    width: 16, 
                    height: 16,
                    wrap: 'clamp',
                    format: "rgba",
                    type: "float"
                });

                this.hitPointsFbo = regl.framebuffer({
                    color: this.hitDataTexture,
                    depth: false
                });

                this.secondaryRayDataTexture = regl.texture({
                    width: 16,
                    height: 16,
                    wrap: 'clamp',
                    min: "nearest", 
                    mag: "nearest",
                    format: "rgba",
                    type: "float",
                });

                this.secondaryRayFbo = regl.framebuffer({
                    color: this.secondaryDataTexture,
                    depth: false
                });

                this.secondaryHitDataTexture = regl.texture({
                    width: 16,
                    height: 16,
                    wrap: 'clamp',
                    min: "nearest", 
                    mag: "nearest",
                    format: "rgba",
                    type: "float",
                });

                this.secondaryHitFbo = regl.framebuffer({
                    color: this.secondaryHitDataTexture,
                    depth: false
                });
            }

            renderGL(scene)
            {
                const regl = this.regl;

                regl.clear({color: [0.0,0.1,0.1,1]});

                const circleData = [
                    [scene["ball"].pos.x, scene["ball"].pos.y, scene["ball"].shape.radius]
                ];

                drawSceneToSDF(regl, {
                    framebuffer: this.sdfFbo,
                    circleData: circleData,
                    outputResolution: [512,512]
                });
                
                drawTexture(regl, {
                    framebuffer: null,
                    texture: this.sdfTexture, 
                    outputResolution: [512,512],
                    exposure: 0.01
                });

                /*
                Upload initial lightrays to texture
                */
                // Create packed lightraydata for each light [[Cx,Cy,Dx,Dy]...]
                const LightSamples = Math.pow(4,4);
                const lightsCount =  Object.entries(scene)
                    .filter( ([key, entity])=>entity.hasOwnProperty("light") ).length;

                const RayCount = LightSamples*lightsCount;
                const [dataWidth, dataHeight] = [Math.ceil(Math.sqrt(RayCount)),Math.ceil(Math.sqrt(RayCount))];

                let rayData = Object.entries(scene)
                    .filter( ([key, entity])=>entity.hasOwnProperty("light") )
                    .map( ([key, entity])=>{
                    return Array.from({length: LightSamples}).map((_, k)=>{
                        const angle = k/LightSamples*Math.PI*2+Math.PI/8.0;
                        return [entity.pos.x, 512-entity.pos.y, Math.cos(angle), Math.sin(angle)];
                    })
                }).flat(1);
                
                // upload data to an RGBA float texture
                this.rayDataTexture({
                    width: dataWidth,
                    height: dataHeight,
                    format: "rgba",
                    type: "float",
                    data: rayData
                });

                /* 
                Intersect Rays with SDF 
                */
                // reformat hitpoints to match the rays count
                this.hitDataTexture({
                    width: dataWidth,
                    height: dataHeight,
                    format: "rgba",
                    type: "float"
                });
                intersectRaysWithSDF(regl, {
                    framebuffer: this.hitPointsFbo, 
                    outputResolution: [512,512],
                    rayDataTexture: this.rayDataTexture,
                    sdfTexture:this.sdfTexture
                });
                
                /* 
                Draw rays stored on texture 
                */
                drawRays(regl, {
                    rayCount: RayCount,
                    rayDataTexture: this.rayDataTexture,
                    hitDataTexture: this.hitDataTexture,
                    outputResolution: [512,512]
                });
                
            }
        }

        function GLViewport({width, height, className})
        {
            const scene = React.useSyncExternalStore(sceneStore.subscribe, sceneStore.getSnapshot);
            const canvasRef = React.useRef(null);
            const renderer = React.useRef(null)
            React.useEffect(()=>{
                renderer.current = new GLRenderer(canvasRef.current);
                renderer.current.initGL();
            }, []);

            React.useEffect(()=>{
                renderer.current.renderGL(scene);
            }, [scene])

            return h("canvas", {width, height, className, ref: canvasRef});
        }

        function App({})
        {
            function handleChange(e)
            {
                console.log(e.key)
                if(e.key === 'Enter')
                {
                    sceneStore.addEntity(e.target.value, {shape: {type: "rectangle", size: 10.0}});
                    e.target.value = ""
                }
            }

            const scene = React.useSyncExternalStore(sceneStore.subscribe, sceneStore.getSnapshot);
            return h("div", {}, 
                h(Outliner),
                h("div", {className: "viewports"},
                    h(GLViewport, {width: 512, height: 512}),
                    h(SVGViewport, {width: 512, height: 512})
                )
            );
        }
        const rdom = ReactDOM.createRoot(document.getElementById('root'));
        rdom.render(React.createElement(App));
    </script>
</body>
</html>