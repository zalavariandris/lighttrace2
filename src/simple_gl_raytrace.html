<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>immer test</title>

    <style>
        .viewports{
            position: relative;
        }
        .viewports>canvas,
        .viewports>svg{
            position: absolute;
            top: 0;
            left:0;

        }
        .viewports>canvas{
            pointer-events: none;
            transform: scale(1, -1);
        }
        .viewports>svg{
            opacity: 0.2;
        }
        .viewports>svg circle{
            stroke: white;
        }
        </style>
	<script type="importmap">
		{
			"imports": {
                "react-dom": "https://cdn.jsdelivr.net/npm/react-dom@18.2.0/+esm",
                "react": "https://cdn.jsdelivr.net/npm/react@18.2.0/+esm",
                "gl-matrix": "https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/+esm",
				"regl": "https://cdn.jsdelivr.net/npm/regl@2.1/+esm",
				"lodash": "https://cdn.jsdelivr.net/npm/lodash@4.17.21/+esm",
				"immer": "https://cdn.jsdelivr.net/npm/immer@10.1.1/+esm",
                "immutable": "https://cdn.jsdelivr.net/npm/immutable@5.0.0-beta.5/+esm"
			}
		}
	</script>
</head>

<body>
	<main id="main">
		<div id="root">
		</div>
	</main>
	<script type="module">
        import React from "react";
        import ReactDOM from "react-dom";
        import {produce} from "immer";
        import createREGL from "regl"
        import Manipulator from "./UI/Manipulator.js"
        import {vec2} from "gl-matrix"
        import _ from "lodash"



class Lightray{
    constructor(origin, direction){
        this.origin = origin;
        this.direction = direction;
    }
}

/*
 * STORE
 */
let scene = {
    "ball": {
        pos: {x: 265.0, y:260.0},
        shape: {type: "circle", radius: 50},
        material: "mirror"
    },
    "ball2": {
        pos: {x: 128.0, y:350.0},
        shape: {type: "circle", radius: 70},
        material: "mirror"
    },
    "ball3": {
        pos: {x: 18.0, y:350.0},
        shape: {type: "circle", radius: 70},
        material: "mirror"
    },
    "light": {
        pos: {x: 255, y: 150},
        light: {type: "point"}
    }
};
let listeners = [];
function emitChange() {
    for (let listener of listeners) {
        listener();
    }
}

const sceneStore = {
    addEntity(key, entity)
    {
        const updatedScene = produce(scene, draft=>{
            draft[key]=entity;
        });

        if(scene!=updatedScene){
            scene=updatedScene;
            emitChange();
        }
    },

    updateComponent(key, component, newAttributes)
    {
        const updatedScene = produce(scene, draft=>{
            Object.assign(draft[key][component], newAttributes);
        });

        if(scene!=updatedScene){
            scene=updatedScene;
            emitChange();
        }
    },

    nudgeShape(key)
    {
        console.log("toggle shape", key)

        const updatedScene = produce(scene, draft=>{
            draft[key]["shape"]["Cx"]+=Math.random()*10-5;
            draft[key]["shape"]["Cy"]+=Math.random()*10-5;
        });
        
        if(scene!=updatedScene){
            scene=updatedScene;
            emitChange();
        }
    },

    removeEntity(key)
    {

    },

    subscribe(listener) 
    {
        listeners = [...listeners, listener];
        return () => {
            listeners = listeners.filter(l => l !== listener);
        };
    },

    getSnapshot() {
        return scene;
    }
}

/*
 * GL Renderer
 */
const QUAD = {
    primitive: "triangle fan",
    attributes: {
        position: [
            [-1,-1],
            [ 1,-1],
            [ 1, 1],
            [-1, 1]
        ],
        uv: [
            [ 0, 0],
            [ 1, 0],
            [ 1, 1],
            [ 0, 1]
        ]
    },
    count: 4
};

const PASS_THROUGH_VERTEX_SHADER = `precision mediump float;
attribute vec2 position;
attribute vec2 uv;
varying vec2 vUV;
void main()
{
    vUV = uv;
    gl_Position = vec4(position, 0, 1);
}`;

const fragmentPreamble = `precision mediump float;
#define e 2.71828
#define PI 3.14159`

// draw Texture to screen
function drawTexture(regl, {
    texture, 
    outputResolution, 
    exposure=1.0,
    framebuffer=null
}={})
{
    regl({...QUAD,
        framebuffer: framebuffer,
        vert: PASS_THROUGH_VERTEX_SHADER,
        depth: { enable: false },
        uniforms:{
            texture: texture,
            outputResolution: outputResolution,
            exposure: exposure
        },
        frag:`precision mediump float;
        uniform sampler2D texture;
        uniform vec2 outputResolution;
        uniform float exposure;
        void main()
        {   
            vec2 UV = gl_FragCoord.xy/outputResolution;
            vec4 color = texture2D(texture, UV);
            gl_FragColor = color*vec4(exposure, exposure, exposure, 1.0);
        }`
    })();
}

/**
 * draw Scene to SignedDistanceField FBO
 * @param {FBO} framebuffer - The OUTPUT framebuffer to render SDF scene
 * @param {Array} circleData - circleData as array of circles eg.: [[centerX, centerY, radius], ...]
 * @param {Array} outputResolution [width, height] - the output resolution of the framebuffer
 */
 function drawSceneToSDF(regl, {
    framebuffer,
    circleData,
    outputResolution
})
{
    regl({...QUAD,
        vert: PASS_THROUGH_VERTEX_SHADER,
        framebuffer: framebuffer,
        depth: { enable: false },
        uniforms:{
            outputResolution: outputResolution,
            circleData: circleData.flat(),
            circleCount: circleData.length
        },
        frag:`precision mediump float;
        #define e 2.71828
        #define PI 3.14159
        #define MAX_CIRCLES 10

        uniform vec3 circleData[MAX_CIRCLES];
        uniform float circleCount;
        uniform vec2 outputResolution;

        float cosh(float x) {
            return (exp(x) + exp(-x)) / 2.0;
        }
        
        float sinh(float x) {
            return (exp(x) - exp(-x)) / 2.0;
        }

        float tanh(float x) {
            return (exp(x) - exp(-x)) / (exp(x) + exp(-x));
        }

        float atanh(float x) {
            return 0.5 * log((1.0 + x) / (1.0 - x));
        }

        vec2 translate(vec2 samplePosition, vec2 offset){
            return samplePosition - offset;
        }

        float rectangle(vec2 samplePosition, vec2 halfSize){
            vec2 componentWiseEdgeDistance = abs(samplePosition) - halfSize;
            float outsideDistance = length(max(componentWiseEdgeDistance, 0.0));
            float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0.0);
            return outsideDistance + insideDistance;
        }

        float circle(vec2 samplePosition, float radius)
        {
            float d = length(samplePosition);
            return length(samplePosition)-radius;
        }

        vec2 rotate(vec2 samplePosition, float angle_in_degrees){
            float angle_in_radians = angle_in_degrees/180.0 * PI * -1.0;
            float sine = sin(angle_in_radians);
            float cosine = cos(angle_in_radians);
            return vec2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x);
        }

        float intersectSDF(float A, float B)
        {
            return max(A, B);
        }

        float unionSDF(float A, float B)
        {
            return min(A, B); 
        }

        float scene(vec2 sceneCoord)
        {
            // collect all circles
            float sceneDistance = 9999.0;
            for(int i=0;i<MAX_CIRCLES;i++)
            {
                if(i<int(circleCount)){
                    vec2 pos = circleData[i].xy;
                    float r = circleData[i].z;
                    float circleDistance = circle(translate(sceneCoord, pos), r);
                    sceneDistance = unionSDF(circleDistance, sceneDistance);
                }
            }
            return sceneDistance; 
        }

        void main()
        {   
            float d = scene(gl_FragCoord.xy);
            // d = abs(d);
            gl_FragColor = vec4(d,d,d,1.0);
        }`
    })();
}

/**
 * Intersect rays with an sdf
 * @param {FBO} framebuffer - The OUTPUT framebuffer to render HitPoint as data vec4(pos, normal)
 * @param {Texture} rayDataTexture - Rays encoded into a texture as data vec4(pos.xy, dir.xy)
 * @param {Texture} sdfTexture - The scene encoded to a signed distance field.
 */
function intersectRaysWithSDF(regl, {
    framebuffer, 
    outputResolution,
    rayDataTexture, 
    sdfTexture,
})
{
    regl({...QUAD, vert:PASS_THROUGH_VERTEX_SHADER,
        framebuffer: framebuffer,
        uniforms:{
            outputResolution: outputResolution,
            rayDataTexture: rayDataTexture,
            rayDataResolution: [rayDataTexture.width, rayDataTexture.height],
            sdfTexture: sdfTexture,
            sdfResolution: [sdfTexture.width, sdfTexture.height]
        },
        frag:`precision mediump float;
        uniform sampler2D rayDataTexture;
        uniform vec2 rayDataResolution;
        uniform sampler2D sdfTexture;
        uniform vec2 sdfResolution;
        uniform vec2 outputResolution;

        #define MAX_RAYMARCH_STEPS 30
        #define MIN_HIT_DISTANCE 1.0
        #define MAX_TRACE_DISTANCE 2048.0

        vec2 sdfNormalAtPoint(vec2 P, sampler2D sdfTexture)
        {
            // Sample distance field texture and neighboring texels
            vec2 texelSize = vec2(1.0/sdfResolution.x, 1.0/sdfResolution.y); 
            vec2 UV = P/sdfResolution;
            float distance = texture2D(sdfTexture, UV).r;
            float distanceRight = texture2D(sdfTexture, UV + vec2(texelSize.x, 0.0)).r;
            float distanceUp = texture2D(sdfTexture, UV + vec2(0.0, texelSize.y)).r;
        
            // Calculate gradients in x and y directions
            float dx = distanceRight - distance;
            float dy = distanceUp - distance;
        
            // Calculate normal vector
            return normalize(vec3(dx, dy, 1.0)).xy; // Negate the gradient and normalize
        }

        vec2 rayMarch(vec2 rayPos, vec2 rayDir, sampler2D sdfTexture)
        {
            vec2 pos = rayPos;
            float totalDistanceTraveled = 0.0;
            for(int i=0; i<MAX_RAYMARCH_STEPS; i++)
            {
                vec2 texCoord = pos/outputResolution;
                float currentDistance = texture2D(sdfTexture, texCoord).r;
                totalDistanceTraveled+=currentDistance;

                // ray did not hit anything within distance threshold
                if(totalDistanceTraveled>MAX_TRACE_DISTANCE)
                {
                    rayDir = normalize(rayDir) * MAX_TRACE_DISTANCE;
                    return rayPos+rayDir;
                }

                // ray hit surface
                if(currentDistance<1.0)
                {
                    rayDir = normalize(rayDir)*distance(pos, rayPos);
                    return rayPos+rayDir;
                }
                pos+=normalize(rayDir)*currentDistance;
            }

            // ray did not hit anythin while raymarching.
            rayDir = normalize(rayDir) * MAX_TRACE_DISTANCE;
            vec2 hitPos = rayPos+rayDir;
            return vec2(hitPos);
        }

        void main()
        {
            // float rayIdx = gl_FragCoord.y*rayDataResolution.x+gl_FragCoord.y;

            // unpack ray from data texture
            vec2 texCoord = gl_FragCoord.xy / rayDataResolution;
            vec4 rayData = texture2D(rayDataTexture, texCoord);
            vec2 rayPos = rayData.xy;
            vec2 rayDir = rayData.zw;

            // intersect ray with signed distance field
            vec2 hitPos = rayMarch(rayPos+normalize(rayDir)*MIN_HIT_DISTANCE*2.0, rayDir, sdfTexture);

            // calculate normal at intersection point
            vec2 hitNormal = sdfNormalAtPoint(hitPos, sdfTexture);

            // output hitData
            gl_FragColor = vec4(hitPos, hitNormal);
        }`
    })();
}



/**
* Draw rays based on rayDataTexture and hitDataTexture
* 
* @param {Texture} params.rayDataTexture - Texture containing ray data in vec4(pos, dir).
* @param {Texture} params.hitDataTexture - Texture containing hit data in vec4(pos, normal).
* @param {[Array]} params.outputResolution - Resolution of the output [width, height].
*/
function drawRays(regl, {
    rayCount,
    rayDataTexture,
    hitDataTexture,
    outputResolution,
    rayColor=[0.9,0.5,0.0,0.3]
}={}){
    regl({
        // viewport: {x: 0, y: 0, w: 1, h: 1},
        depth: { enable: false },
        primitive: "lines",
        attributes: {
            vertexIdx: _.range(rayCount*2),
        },
        count: rayCount*2,
        uniforms:{
            rayDataTexture: rayDataTexture,
            rayDataResolution: [rayDataTexture.width, rayDataTexture.height],
            hitDataTexture: hitDataTexture,
            hitDataResolution: [hitDataTexture.width, hitDataTexture.height],
            outputResolution: outputResolution,
            rayColor: rayColor
        },
        blend: {
            enable: true,
            func: {
                srcRGB: 'src alpha',
                srcAlpha: 1,
                dstRGB: 'one minus src alpha',
                dstAlpha: 1
            },
            equation: {
                rgb: 'add',
                alpha: 'add'
            },
            color: [0, 0, 0, 0]
        },
        vert: `precision mediump float;
            #define MAX_RAYMARCH_STEPS 9
            #define MIN_HIT_DISTANCE 1.0
            #define MAX_TRACE_DISTANCE 250.0

            attribute float vertexIdx;
            uniform sampler2D rayDataTexture;
            uniform vec2 rayDataResolution;
            uniform sampler2D hitDataTexture;
            uniform vec2 hitDataResolution;
            
            uniform vec2 outputResolution;

            float modI(float a,float b)
            {
                float m = a-floor((a+0.5)/b)*b;
                return floor(m+0.5);
            }

            vec2 mapToScreen(vec2 P)
            {
                return (P / outputResolution.xy * 2.0 - 1.0);
            }

            void main()
            {
                float lineIdx = floor(vertexIdx/2.0);

                // Sample rayData
                float pixelX = mod(lineIdx, rayDataResolution.x);
                float pixelY = floor(lineIdx / rayDataResolution.x);
                // Calculate the texture coordinates for the center of the texel corresponding to vertexIdx
                vec2 texCoords = (vec2(pixelX, pixelY) + 0.5) / rayDataResolution;
                // Sample the rayData texture at the calculated UV coordinates
                vec4 rayData = texture2D(rayDataTexture, texCoords);

                vec4 hitData = texture2D(hitDataTexture, texCoords);

                // Extract the position and direction from the sampled data
                vec2 rayPos = rayData.xy;
                vec2 hitPos = hitData.xy;

                bool IsLineStartPoint = modI(vertexIdx, 2.0) < 1.0;
                if(IsLineStartPoint){
                    vec2 screenPos = mapToScreen(rayPos);
                    gl_Position = vec4(screenPos, 0, 1);
                }
                else
                {
                    vec2 screenPos = mapToScreen(hitPos);
                    gl_Position = vec4(screenPos, 0, 1);
                }
            }`,

        frag:`precision mediump float;
        uniform vec4 rayColor;
        void main()
        {
            gl_FragColor = vec4(rayColor);
        }`
    })();
}

/**
* Create secondary rays 
* 
* @param {Framebuffer} params.outputFramebuffer - Trget framebuffer to render secondary rays in vec4(pos, dir).
* @param {[Array]} params.outputResolution - Resolution of the output [width, height].
* @param {Texture} params.incidentRaysTexture - Texture containing ray data in vec4(pos, dir).
* @param {Texture} params.hitDataTexture - Texture containing hit data in vec4(pos, normal).
*/
function raytraceSecondaryRays(regl, {
    outputFramebuffer,
    outputResolution,
    incidentRaysTexture,
    hitDataTexture
}){
    regl({...QUAD, vert:PASS_THROUGH_VERTEX_SHADER,
        framebuffer: outputFramebuffer,
        uniforms:{
            outputResolution: outputResolution,
            incidentRaysTexture: incidentRaysTexture,
            rayDataResolution: [incidentRaysTexture.width, incidentRaysTexture.height],
            hitDataTexture: hitDataTexture,
            hitDataResolution: [hitDataTexture.width, hitDataTexture.height]
        },
        frag:`precision mediump float;
        uniform vec2 outputResolution;
        uniform sampler2D incidentRaysTexture;
        uniform vec2 rayDataResolution;
        uniform sampler2D hitDataTexture;
        uniform vec2 hitDataResolution;
        void main()
        {

            vec2 rayDir = texture2D(incidentRaysTexture, gl_FragCoord.xy/outputResolution.xy).zw;

            vec4 hitData = texture2D(hitDataTexture, gl_FragCoord.xy/outputResolution.xy);
            vec2 hitNormal = hitData.zw;
            vec2 hitPos = hitData.xy;

            vec2 secondaryDir = reflect(normalize(rayDir), normalize(hitNormal));
            vec2 secondaryPos = hitPos;
            gl_FragColor = vec4(secondaryPos, secondaryDir);
        }`
    })()
}

class GLRenderer{
    constructor(canvas)
    {
        this.canvas = canvas;
        this.LightSamples = 4*4; //Math.pow(4,4);
    }

    initGL()
    {
        this.regl = createREGL({
            canvas: this.canvas,
            // pixelRatio: 2.0,
            attributes: {
                // width: 1024, heigh: 1024,
                alpha: true,
                depth: true,
                stencil :false,
                antialias: true,
                premultipliedAlpha: true,
                preserveDrawingBuffer: false,
                preferLowPowerToHighPerformance: false,
                failIfMajorPerformanceCaveat: false
            },
            extensions: ['OES_texture_float', "OES_texture_half_float"]
        });
        const regl = this.regl;

        this.sdfTexture = regl.texture({
            width: 512, 
            height: 512,
            wrap: 'clamp',
            format: "rgba",
            type: "float"
        });

        this.sdfFbo = regl.framebuffer({
            color: this.sdfTexture,
            depth: false
        });

        this.rayDataTexture = regl.texture({
            width: Math.sqrt(this.LightSamples),
            height: Math.sqrt(this.LightSamples),
            wrap: 'clamp',
            min: "nearest", 
            mag: "nearest",
            format: "rgba",
            type: "float",
        });

        this.rayDataFbo = regl.framebuffer({
            color: this.rayDataTexture,
            depth: false
        });

        this.hitDataTexture = regl.texture({
            width: Math.sqrt(this.LightSamples), 
            height: Math.sqrt(this.LightSamples),
            wrap: 'clamp',
            format: "rgba",
            type: "float"
        });

        this.hitDataFbo = regl.framebuffer({
            color: this.hitDataTexture,
            depth: false
        });

        this.secondaryRayDataTexture = regl.texture({
            width: Math.sqrt(this.LightSamples),
            height: Math.sqrt(this.LightSamples),
            wrap: 'clamp',
            min: "nearest", 
            mag: "nearest",
            format: "rgba",
            type: "float",
        });

        this.secondaryRayDataFbo = regl.framebuffer({
            color: this.secondaryRayDataTexture,
            depth: false
        });

        this.secondaryHitDataTexture = regl.texture({
            width: Math.sqrt(this.LightSamples),
            height: Math.sqrt(this.LightSamples),
            wrap: 'clamp',
            min: "nearest", 
            mag: "nearest",
            format: "rgba",
            type: "float",
        });

        this.secondaryHitDataFbo = regl.framebuffer({
            color: this.secondaryHitDataTexture,
            depth: false
        });
    }

    renderGL(scene)
    {
        const regl = this.regl;

        regl.clear({color: [0.03,0.03,0.03,1.0]});

        const circleData = Object.entries(scene)
            .filter(([key, entity])=>entity.hasOwnProperty("pos") && entity.hasOwnProperty("shape") && entity.shape.type=="circle")
            .map( ([key, entity])=>[entity.pos.x, entity.pos.y, entity.shape.radius] )
        // const circleData = [
        //     [scene["ball"].pos.x, scene["ball"].pos.y, scene["ball"].shape.radius]
        // ];

        drawSceneToSDF(regl, {
            framebuffer: this.sdfFbo,
            circleData: circleData,
            outputResolution: [512,512]
        });
        
        drawTexture(regl, {
            framebuffer: null,
            texture: this.sdfTexture, 
            outputResolution: [512,512],
            exposure: 0.001
        });

        /*
        Upload initial lightrays to texture
        */

        // Create packed lightraydata for each light [[Cx,Cy,Dx,Dy]...]
        const LightSamples = this.LightSamples;
        console.log(LightSamples)

        const lightsCount =  Object.entries(scene)
            .filter( ([key, entity])=>entity.hasOwnProperty("light") ).length;

        const RayCount = LightSamples*lightsCount;
        const [dataWidth, dataHeight] = [Math.ceil(Math.sqrt(RayCount)),Math.ceil(Math.sqrt(RayCount))];

        let rayData = Object.entries(scene)
            .filter( ([key, entity])=>entity.hasOwnProperty("light") )
            .map( ([key, entity])=>{
            return Array.from({length: LightSamples}).map((_, k)=>{
                const angle = k/LightSamples*Math.PI*2+Math.PI/8.0;
                return [entity.pos.x, entity.pos.y, Math.cos(angle), Math.sin(angle)];
            })
        }).flat(1);
        
        // upload data to an RGBA float texture
        this.rayDataTexture({
            width: dataWidth,
            height: dataHeight,
            format: "rgba",
            type: "float",
            data: rayData
        });

        /* 
        Intersect Rays with SDF 
        */
        // reformat hitpoints to match the rays count
        this.hitDataTexture({
            width: dataWidth,
            height: dataHeight,
            format: "rgba",
            type: "float"
        });

        intersectRaysWithSDF(regl, {
            framebuffer: this.hitDataFbo, 
            outputResolution: [512,512],
            rayDataTexture: this.rayDataTexture,
            sdfTexture:this.sdfTexture
        });
        
        /* 
        Draw rays stored on texture 
        */
        drawRays(regl, {
            rayCount: RayCount,
            rayDataTexture: this.rayDataTexture,
            hitDataTexture: this.hitDataTexture,
            outputResolution: [512,512],
            rayColor: [1,1,1,100.0/this.LightSamples]
        });

        /*
         * RAYTRACE Bounces 
         */
        const MAX_BOUNCE = 2;
        for(let i=0; i<MAX_BOUNCE; i++)
        {
            raytraceSecondaryRays(regl, {
                outputFramebuffer: this.secondaryRayDataFbo,
                outputResolution: [dataWidth, dataHeight],
                incidentRaysTexture: this.rayDataFbo, 
                hitDataTexture: this.hitDataFbo
            });

            // reformat hitpoints to match the rays count
            this.secondaryHitDataTexture({
                width: dataWidth,
                height: dataHeight,
                format: "rgba",
                type: "float"
            });

            // intrsect secondary rays with sdf
            intersectRaysWithSDF(regl, {
                framebuffer: this.secondaryHitDataFbo, 
                outputResolution: [512,512],
                rayDataTexture: this.secondaryRayDataFbo,
                sdfTexture:this.sdfTexture
            });

            // draw secondary rays
            drawRays(regl, {
                rayCount: RayCount,
                rayDataTexture: this.secondaryRayDataFbo,
                hitDataTexture: this.secondaryHitDataFbo,
                outputResolution: [512,512],
                rayColor: [1,1,1,100.0/this.LightSamples]
            });

            // swap buffers
            [this.rayDataFbo, this.secondaryRayDataFbo] = [this.secondaryRayDataFbo, this.rayDataFbo]
            // [this.rayDataTexture, this.secondaryRayDataTexture] = [this.secondaryRayDataTexture, this.rayDataTexture];
            [this.hitDataFbo, this.secondaryHitDataFbo] = [this.secondaryHitDataFbo, this.hitDataFbo]
            // [this.hitDataTexture, this.secondaryHitDataTexture] = [this.secondaryHitDataTexture, this.hitDataTexture]
        }


        
    }
}

/*
 * VIEWS
 */
const h = React.createElement;

function Outliner({})
{
    const scene = React.useSyncExternalStore(sceneStore.subscribe, sceneStore.getSnapshot);
    return h("ul", {}, 
        Object.entries(scene)
            .filter(([key, entity])=>entity.hasOwnProperty("pos"))
            .map( ([key, entity])=>{
            return h("li", null, 
                `${key}: (${entity.pos.x},${entity.pos.y})`
            )
        })
    );
}

function SVGViewport({width, height, className})
{
    const scene = React.useSyncExternalStore(sceneStore.subscribe, sceneStore.getSnapshot);

    return h("svg", {width, height, className}, 
        Object.entries(scene).filter(([key, entity])=>entity.hasOwnProperty("shape")).map( ([key, entity])=>{
            return h(Manipulator, {
                referenceX: entity.pos.x,
                referenceY: entity.pos.y,
                onDrag: e=>sceneStore.updateComponent(key, "pos", {
                    x: e.sceneX+e.referenceOffsetX, 
                    y: e.sceneY+e.referenceOffsetY
                }),
            }, 
                h("circle", {cx: entity.pos.x, cy: entity.pos.y, r:entity.shape.radius})
            )
        }),
        Object.entries(scene)
            .filter(([key, entity])=>entity.hasOwnProperty("pos") && entity.hasOwnProperty("light"))
            .map( ([key, entity])=>{
            return h(Manipulator, {
                referenceX: entity.pos.x,
                referenceY: entity.pos.y,
                onDrag: e=>sceneStore.updateComponent(key, "pos", {
                    x: e.sceneX+e.referenceOffsetX, 
                    y: e.sceneY+e.referenceOffsetY
                }),
            }, 
                h("circle", {cx: entity.pos.x, cy: entity.pos.y, r:10, style:{fill:"orange"}})
            )
        })
    );
}

function GLViewport({width, height, className})
{
    const scene = React.useSyncExternalStore(sceneStore.subscribe, sceneStore.getSnapshot);
    const canvasRef = React.useRef(null);
    const renderer = React.useRef(null)
    React.useEffect(()=>{
        renderer.current = new GLRenderer(canvasRef.current);
        renderer.current.initGL();
    }, []);

    React.useEffect(()=>{
        renderer.current.renderGL(scene);
    }, [scene])

    return h("canvas", {width, height, className, ref: canvasRef});
}

function App({})
{
    function handleChange(e)
    {
        console.log(e.key)
        if(e.key === 'Enter')
        {
            sceneStore.addEntity(e.target.value, {shape: {type: "rectangle", size: 10.0}});
            e.target.value = ""
        }
    }

    const scene = React.useSyncExternalStore(sceneStore.subscribe, sceneStore.getSnapshot);
    return h("div", {}, 
        h(Outliner),
        h("div", {className: "viewports"},
            h(GLViewport, {width: 512, height: 512}),
            h(SVGViewport, {width: 512, height: 512})
        )
    );
}

const rdom = ReactDOM.createRoot(document.getElementById('root'));
rdom.render(React.createElement(App));
    </script>
</body>
</html>