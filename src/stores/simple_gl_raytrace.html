<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>immer test</title>

    <style>
        .viewports{
            position: relative;
        }
        .viewports>canvas,
        .viewports>svg{
            position: absolute;
            top: 0;
            left:0;
            border: 1px solid black;
        }
        .viewports>canvas{
            pointer-events: none;
        }
        </style>
	<script type="importmap">
		{
			"imports": {
                "react-dom": "https://cdn.jsdelivr.net/npm/react-dom@18.2.0/+esm",
                "react": "https://cdn.jsdelivr.net/npm/react@18.2.0/+esm",
                "gl-matrix": "https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/+esm",
				"regl": "https://cdn.jsdelivr.net/npm/regl@2.1/+esm",
				"lodash": "https://cdn.jsdelivr.net/npm/lodash@4.17.21/+esm",
				"immer": "https://cdn.jsdelivr.net/npm/immer@10.1.1/+esm",
                "immutable": "https://cdn.jsdelivr.net/npm/immutable@5.0.0-beta.5/+esm"
			}
		}
	</script>
</head>

<body>
	<main id="main">
		<div id="root">
		</div>
	</main>
	<script type="module">
        import React from "react";
        import ReactDOM from "react-dom";
        import {produce} from "immer";
        import createREGL from "regl"
        import Manipulator from "../UI/Manipulator.js"
        import {vec2} from "gl-matrix"
        import _ from "lodash"
        window._ = _

        class Lightray{
            constructor(origin, direction){
                this.origin = origin;
                this.direction = direction;
            }
        }


        let scene = {
            "ball": {
                pos: {x: 5.0, y:5.0},
                shape: {type: "circle", radius: 50},
                material: "mirror"
            },
            "light": {
                pos: {x: 50, y: 50},
                light: {type: "point"}
            }
        };
        let listeners = [];
        function emitChange() {
            for (let listener of listeners) {
                listener();
            }
        }

        const sceneStore = {
            addEntity(key, entity)
            {
                const updatedScene = produce(scene, draft=>{
                    draft[key]=entity;
                });

                if(scene!=updatedScene){
                    scene=updatedScene;
                    emitChange();
                }
            },

            updateComponent(key, component, newAttributes)
            {
                const updatedScene = produce(scene, draft=>{
                    Object.assign(draft[key][component], newAttributes);
                });

                if(scene!=updatedScene){
                    scene=updatedScene;
                    emitChange();
                }
            },

            nudgeShape(key)
            {
                console.log("toggle shape", key)

                const updatedScene = produce(scene, draft=>{
                    draft[key]["shape"]["Cx"]+=Math.random()*10-5;
                    draft[key]["shape"]["Cy"]+=Math.random()*10-5;
                });
                
                if(scene!=updatedScene){
                    scene=updatedScene;
                    emitChange();
                }
            },

            removeEntity(key)
            {

            },

            subscribe(listener) 
            {
                listeners = [...listeners, listener];
                return () => {
                    listeners = listeners.filter(l => l !== listener);
                };
            },

            getSnapshot() {
                return scene;
            }
        }

        const h = React.createElement;

        function Outliner({})
        {
            const scene = React.useSyncExternalStore(sceneStore.subscribe, sceneStore.getSnapshot);
            return h("ul", {}, 
                Object.entries(scene)
                    .filter(([key, entity])=>entity.hasOwnProperty("pos"))
                    .map( ([key, entity])=>{
                    return h("li", null, 
                        `${key}: (${entity.pos.x},${entity.pos.y})`
                    )
                })
            );
        }

        function SVGViewport({width, height, className})
        {
            const scene = React.useSyncExternalStore(sceneStore.subscribe, sceneStore.getSnapshot);

            return h("svg", {width, height, className}, 
                Object.entries(scene).filter(([key, entity])=>entity.hasOwnProperty("shape")).map( ([key, entity])=>{
                    return h(Manipulator, {
                        referenceX: entity.pos.x,
                        referenceY: entity.pos.y,
                        onDrag: e=>sceneStore.updateComponent(key, "pos", {
                            x: e.sceneX+e.referenceOffsetX, 
                            y: e.sceneY+e.referenceOffsetY
                        }),
                    }, 
                        h("circle", {cx: entity.pos.x, cy: entity.pos.y, r:30})
                    )
                }),
                Object.entries(scene)
                    .filter(([key, entity])=>entity.hasOwnProperty("pos") && entity.hasOwnProperty("light"))
                    .map( ([key, entity])=>{
                    return h(Manipulator, {
                        referenceX: entity.pos.x,
                        referenceY: entity.pos.y,
                        onDrag: e=>sceneStore.updateComponent(key, "pos", {
                            x: e.sceneX+e.referenceOffsetX, 
                            y: e.sceneY+e.referenceOffsetY
                        }),
                    }, 
                        h("circle", {cx: entity.pos.x, cy: entity.pos.y, r:10, style:{fill:"orange"}})
                    )
                })
            );
        }

        class GLRenderer{
            constructor(canvas)
            {
                this.canvas = canvas;
            }

            initGL()
            {
                this.regl = createREGL({
                    canvas: this.canvas,
                    // pixelRatio: 2.0,
                    attributes: {
                        // width: 1024, heigh: 1024,
                        alpha: true,
                        depth: true,
                        stencil :false,
                        antialias: true,
                        premultipliedAlpha: true,
                        preserveDrawingBuffer: false,
                        preferLowPowerToHighPerformance: false,
                        failIfMajorPerformanceCaveat: false
                    },
                    extensions: ['OES_texture_float', "OES_texture_half_float"]
                });
                const regl = this.regl;

                this.sdfTexture = regl.texture({
                    width: 512, 
                    height: 512,
                    wrap: 'clamp',
                    format: "rgba",
                    type: "float"
                });

                this.sdfFbo = regl.framebuffer({
                    color: this.sdfTexture,
                    depth: false
                });
            }

            renderGL(scene)
            {
                const regl = this.regl;

                regl.clear({color: [0.0,0.1,0.1,1]});

                const circleData = new Float32Array([
                    scene["ball"].pos.x, 512-scene["ball"].pos.y, scene["ball"].shape.radius
                ].flat(1));

                // draw SignedDistanceField to FBO
                regl({
                    framebuffer: this.sdfFbo,
                    depth: { enable: false },
                    primitive: "triangle fan",
                    attributes: {
                        position: [
                            [-1,-1],
                            [ 1,-1],
                            [ 1, 1],
                            [-1, 1]
                        ],
                    },
                    count: 4,
                    uniforms:{
                        outputResolution: [512,512],
                        circleData: circleData,
                        circleCount: 1
                    },
                    vert: `precision mediump float;
                        attribute vec2 position;
                        void main()
                        {
                            gl_Position = vec4(position, 0, 1);
                        }`,

                    frag:`precision mediump float;
                    #define e 2.71828
                    #define PI 3.14159
                    #define MAX_CIRCLES 10


                    uniform vec3 circleData[MAX_CIRCLES];
                    uniform float circleCount;

                    float cosh(float x) {
                        return (exp(x) + exp(-x)) / 2.0;
                    }
                    
                    float sinh(float x) {
                        return (exp(x) - exp(-x)) / 2.0;
                    }

                    float tanh(float x) {
                        return (exp(x) - exp(-x)) / (exp(x) + exp(-x));
                    }

                    float atanh(float x) {
                        return 0.5 * log((1.0 + x) / (1.0 - x));
                    }

                    vec2 translate(vec2 samplePosition, vec2 offset){
                        return samplePosition - offset;
                    }

                    float rectangle(vec2 samplePosition, vec2 halfSize){
                        vec2 componentWiseEdgeDistance = abs(samplePosition) - halfSize;
                        float outsideDistance = length(max(componentWiseEdgeDistance, 0.0));
                        float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0.0);
                        return outsideDistance + insideDistance;
                    }

                    float circle(vec2 samplePosition, float radius)
                    {
                        float d = length(samplePosition);
                        return length(samplePosition)-radius;
                    }

                    vec2 rotate(vec2 samplePosition, float angle_in_degrees){
                        float angle_in_radians = angle_in_degrees/180.0 * PI * -1.0;
                        float sine = sin(angle_in_radians);
                        float cosine = cos(angle_in_radians);
                        return vec2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x);
                    }

                    float intersectSDF(float A, float B)
                    {
                        return max(A, B);
                    }

                    float unionSDF(float A, float B)
                    {
                        return min(A, B); 
                    }

                    float scene(vec2 sceneCoord)
                    {
                        // collect all circles
                        float sceneDistance = 9999.0;
                        for(int i=0;i<1;i++)
                        {
                            vec2 pos = circleData[i].xy;
                            float r = circleData[i].z;
                            float circleDistance = circle(translate(sceneCoord, pos), r);
                            sceneDistance = unionSDF(circleDistance, sceneDistance);
                        }
                        return sceneDistance; 
                    }

                    void main()
                    {   
                        float d = scene(gl_FragCoord.xy)*1.0;
                        // d = abs(d);
                        gl_FragColor = vec4(d,d,d,1.0);
                    }`
                })();

                // draw sdf texture to screen
                regl({
                    depth: { enable: false },
                    primitive: "triangle fan",
                    attributes: {
                        position: [
                            [-1,-1],
                            [ 1,-1],
                            [ 1, 1],
                            [-1, 1]
                        ],
                    },
                    count: 4,
                    uniforms:{
                        outputResolution: [512,512],
                        sdfTexture: this.sdfTexture
                    },
                    vert: `precision mediump float;
                    attribute vec2 position;
                    void main()
                    {
                        gl_Position = vec4(position, 0, 1);
                    }`,

                    frag:`precision mediump float;
                    uniform sampler2D sdfTexture;
                    uniform vec2 outputResolution;

                    void main()
                    {
                        vec2 UV = gl_FragCoord.xy/outputResolution;
                        float d = texture2D(sdfTexture, UV).r*0.001;
                        d = abs(d);
                        float c = smoothstep(0.0,0.01,d);
                        gl_FragColor = vec4(c,c,c+0.3,1.0);
                    } `
                })();

                // Create packed lightraydata for each light [[Cx,Cy,Dx,Dy]...]
                const LightSamples = Math.pow(4,4);
                const lightsCount =  Object.entries(scene)
                    .filter( ([key, entity])=>entity.hasOwnProperty("light") ).length;

                const RayCount = LightSamples*lightsCount;
                const [dataWidth, dataHeight] = [Math.ceil(Math.sqrt(RayCount)),Math.ceil(Math.sqrt(RayCount))];

                console.log(RayCount, dataWidth, dataHeight);
                let rayData = Object.entries(scene)
                    .filter( ([key, entity])=>entity.hasOwnProperty("light") )
                    .map( ([key, entity])=>{
                    return Array.from({length: LightSamples}).map((_, k)=>{
                        const angle = k/LightSamples*Math.PI*2+Math.PI/8.0;
                        return [entity.pos.x, entity.pos.y, Math.cos(angle), Math.sin(angle)];
                    })
                }).flat(1);
                
                // upload data to an RGBA float texture

                const rayDataTexture = regl.texture({
                    width: dataWidth,
                    height: dataHeight,
                    wrap: 'clamp',
                    min: "nearest", 
                    mag: "nearest",
                    format: "rgba",
                    type: "float",
                });

                rayDataTexture({
                    width: dataWidth,
                    height: dataHeight,
                    format: "rgba",
                    type: "float",
                    data: rayData
                });

                // draw rayDataTexture to screen
                // regl({
                //     // viewport: {x: 0, y: 0, w: 1, h: 1},
                //     depth: { enable: false },
                //     primitive: "triangle fan",
                //     attributes: {
                //         position: [
                //             [-1,-1],
                //             [ 1,-1],
                //             [ 1, 1],
                //             [-1, 1]
                //         ],
                //     },
                //     count: 4,
                //     uniforms:{
                //         rayDataTexture: rayDataTexture,
                //         dataResolution: [dataWidth, dataHeight],
                //         outputResolution: [512,512]
                //     },
                //     vert: `precision mediump float;
                //         attribute vec2 position;
                //         void main()
                //         {
                //             gl_Position = vec4(position, 0, 1);
                //         }`,

                //     frag:`precision mediump float;
                //     uniform sampler2D rayDataTexture;
                //     uniform vec2 dataResolution;
                //     uniform vec2 outputResolution;
                //     void main()
                //     {   
                //         vec2 UV = gl_FragCoord.xy/outputResolution;
                //         vec4 rayData = texture2D(rayDataTexture, UV);
                //         gl_FragColor = vec4(rayData.zw/2.0+0.5, 0.0,1.0);
                //     }`
                // })();
                
                // draw rays based on rayDataTexture and intersect with sdf
                regl({
                    // viewport: {x: 0, y: 0, w: 1, h: 1},
                    depth: { enable: false },
                    primitive: "lines",
                    attributes: {
                        vertexIdx: _.range(RayCount*2),
                    },
                    count: RayCount*2,
                    uniforms:{
                        rayDataTexture: rayDataTexture,
                        dataResolution: [dataWidth, dataHeight],
                        sdfTexture: this.sdfTexture,
                        outputResolution: [512,512]
                    },
                    blend: {
                        enable: true,
                        func: {
                            srcRGB: 'src alpha',
                            srcAlpha: 1,
                            dstRGB: 'one minus src alpha',
                            dstAlpha: 1
                        },
                        equation: {
                            rgb: 'add',
                            alpha: 'add'
                        },
                        color: [0, 0, 0, 0]
                    },
                    vert: `precision mediump float;
                        #define MAX_RAYMARCH_STEPS 9
                        #define MIN_HIT_DISTANCE 1.0;
                        #define MAX_DISTANCE 250.0

                        attribute float vertexIdx;
                        uniform sampler2D rayDataTexture;
                        uniform sampler2D sdfTexture;
                        uniform vec2 dataResolution;
                        uniform vec2 outputResolution;

                        struct Ray
                        {
                            vec2 pos;
                            vec2 dir;
                        };

                        Ray unpackRay(vec4 rayData)
                        {
                            return Ray(rayData.xy, rayData.zw);
                        }

                        float modI(float a,float b)
                        {
                            float m = a-floor((a+0.5)/b)*b;
                            return floor(m+0.5);
                        }

                        vec2 mapToScreen(vec2 P)
                        {
                            return (P / outputResolution.xy * 2.0 - 1.0) * vec2(1, -1);
                        }

                        float sdf(vec2 sceneCoord)
                        {
                            vec2 texCoord = sceneCoord/outputResolution.xy;
                            texCoord = vec2(texCoord.x, 1.0-texCoord.y);
                            return texture2D(sdfTexture, texCoord).r;
                        }

                        struct HitPoint{
                            vec2 pos;
                        };

                        bool hitTest(Ray ray, sampler2D sdf)
                        {
                            HitPoint(vec2(0,0));
                            return true;
                        }

                        Ray rayMarch(Ray ray)
                        {
                            vec2 pos = ray.pos;
                            float totalDistanceTraveled = 0.0;
                            for(int i=0; i<MAX_RAYMARCH_STEPS; i++){
                                float currentDistance = sdf(pos);
                                totalDistanceTraveled+=currentDistance;
                                if(totalDistanceTraveled>MAX_DISTANCE){
                                    ray.dir = normalize(ray.dir) * MAX_DISTANCE;
                                    return ray;
                                }
                                if(currentDistance<1.0)
                                {
                                    ray.dir = normalize(ray.dir)*distance(pos, ray.pos);
                                    return ray;
                                }
                                pos+=normalize(ray.dir)*currentDistance;
                            }

                            ray.dir = normalize(ray.dir) * MAX_DISTANCE;
                            return ray;
                        }

 
                        void main()
                        {
                            float lineIdx = floor(vertexIdx/2.0);
                            float pixelX = mod(lineIdx, dataResolution.x);
                            float pixelY = floor(lineIdx / dataResolution.x);
                            float EPSILON = 5.0;

                            // Calculate the texture coordinates for the center of the texel corresponding to vertexIdx
                            vec2 texCoords = (vec2(pixelX, pixelY) + 0.5) / dataResolution;

                            // Sample the texture at the calculated UV coordinates
                            vec4 rayData = texture2D(rayDataTexture, texCoords);

                            // Extract the position and direction from the sampled data
                            Ray ray = unpackRay(rayData);

                            bool IsLineStartPoint = modI(vertexIdx, 2.0) < 1.0;
                            if(IsLineStartPoint){
                                vec2 screenPos = mapToScreen(ray.pos);
                                gl_Position = vec4(screenPos, 0, 1);
                            }
                            else
                            {
                                ray = rayMarch(ray);
                                vec2 screenPos = mapToScreen(ray.pos+ray.dir*1.0);
                                gl_Position = vec4(screenPos, 0, 1);
                            }

                            // draw line vertices
                            
                            
                            
                        }`,

                    frag:`precision mediump float;
                    void main()
                    {
                        gl_FragColor = vec4(1.0,0.0, 0.0, 0.3);
                    }`
                })();
            }
        }

        function GLViewport({width, height, className})
        {
            const scene = React.useSyncExternalStore(sceneStore.subscribe, sceneStore.getSnapshot);
            const canvasRef = React.useRef(null);
            const renderer = React.useRef(null)
            React.useEffect(()=>{
                renderer.current = new GLRenderer(canvasRef.current);
                renderer.current.initGL();
            }, []);

            React.useEffect(()=>{
                renderer.current.renderGL(scene);
            }, [scene])

            return h("canvas", {width, height, className, ref: canvasRef});
        }

        function App({})
        {
            function handleChange(e)
            {
                console.log(e.key)
                if(e.key === 'Enter')
                {
                    sceneStore.addEntity(e.target.value, {shape: {type: "rectangle", size: 10.0}});
                    e.target.value = ""
                }
            }

            const scene = React.useSyncExternalStore(sceneStore.subscribe, sceneStore.getSnapshot);
            return h("div", {}, 
                h(Outliner),
                h("div", {className: "viewports"},
                    h(GLViewport, {width: 512, height: 512}),
                    h(SVGViewport, {width: 512, height: 512})
                )
            );
        }
        const rdom = ReactDOM.createRoot(document.getElementById('root'));
        rdom.render(React.createElement(App));
    </script>
</body>
</html>