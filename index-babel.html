<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Lighttrace 2</title>
  <link rel="stylesheet" href="styles.css">
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
      }
    }
  </script>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script type="text/javascript" src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/regl/2.1.0/regl.js" integrity="sha512-FgmtfNZApTrLMIs/sEBR+RjqVxVqJM7iloUqYLlp2YFFqn7zyDVJ8FllBZMBMHKc2mAXZQ+lLy2ZizpXmI5PdA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  
</head>

<body>
  <h1>Light Tracer 2D v2.1</h1>
  <main id="main">
    <div id="root">
    </div>
  </main>
  
  <script type="text/babel">
    class Circle{
      constructor(center,radius){
        this.center = center, this.radius=radius;
      }

      copy(other){
        return new Circle(this.center.copy(), this.radius)
      }
    }
    
    class Rectangle {
      constructor(center, width, height) {
          this.center = center;
          this.width = width;
          this.height = height;
      }

      copy(other){
        return new Rectangle(this.center.copy(), this.width, this.height)
      }
  }

  class LineSegment {
  constructor(p1, p2) { 
    this.p1 = p1;
    this.p2 = p2;
  }
  copy(other){
    return new LineSegment(this.p1.copy(), this.p2.copy())
  }
}
    
    class Point{
      constructor(x,y){this.x=x; this.y=y;}
      copy(other){
        return new Point(this.x, this.y)
      }
      distance(p){
        const dx = this.x-p.x;
        const dy = this.y-p.y;
        return Math.sqrt(dx * dx + dy * dy);
      }
    }
    class Vector{
      constructor(x,y){this.x=x; this.y=y;}
      copy(other){
        return new Point(this.x, this.y)
      }
      dotProduct(vector) {
        return this.x * vector.x + this.y * vector.y;
      }
      
      magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      
      normalize(value=1.0) {
        const magnitude = this.magnitude();
        this.x = this.x / magnitude * value
        this.y = this.y / magnitude*value;
      }
      
      normalized(value=1.0) {
        const magnitude = this.magnitude();
        return new Vector(this.x / magnitude * value, this.y / magnitude*value);
      }
      
      reflect(normal) {
        const dotProduct = this.dotProduct(normal);
        const reflectedX = this.x - 2 * dotProduct * normal.x;
        const reflectedY = this.y - 2 * dotProduct * normal.y;
        return new Vector(reflectedX, reflectedY);
      }
    }
    
    class Ray{
      constructor(origin, direction)
      {
        console.assert(origin instanceof Point, `origin must be a Point, got: ${origin}`)
        console.assert(direction instanceof Vector, `direction must be a vector, got: ${direction}`)
        this.origin=origin; this.direction=direction;
      }

      copy(other){
        return new Ray(this.origin.copy(), this.direction.copy())
      }
      
      intersectCircle(circle)
      {
        // 
        const d = new Vector(this.origin.x - circle.center.x, this.origin.y - circle.center.y);
        const a = this.direction.dotProduct(this.direction);
        const b = 2 * this.direction.dotProduct(d);
        const c = d.dotProduct(d) - circle.radius * circle.radius;
        const discriminant = b * b - 4 * a * c;
        
        if (discriminant < 0) {
          return [];
        }
        
        const t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
        const t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
        
        const t = Math.min(t1, t2);
        
        if (t < 0) {
          return [];
        }
        const origin = P(this.origin.x + t * this.direction.x, this.origin.y + t * this.direction.y);
        const direction = V(origin.x - circle.center.x, origin.y - circle.center.y).normalized();
        
        return [new Ray(origin, direction)];
      }

      intersectLineSegment(lineSegment) {
        const p1 = lineSegment.p1;
        const p2 = lineSegment.p2;
        const p3 = this.origin;
        const p4 = new Point(this.origin.x + this.direction.x, this.origin.y + this.direction.y);

        
        
        const denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

        if (denominator === 0) {
          return [];
        }

        const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
        const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

        if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {
          return [];
        }

        const intersection_point = new Point(p1.x + ua * (p2.x - p1.x), p1.y + ua * (p2.y - p1.y))

        const segment_normal = V(p2.y-p1.y, p2.x-p1.x).normalized()
        return [new Ray(intersection_point, segment_normal)];
      }

      intersectRectangle(rectangle) {
        
        const top = rectangle.center.y+rectangle.height/2
        const left = rectangle.center.x-rectangle.width/2
        const bottom = rectangle.center.y-rectangle.height/2
        const right = rectangle.center.x+rectangle.width/2

        const topLeft = new Point(left, top)
        const bottomRight = new Point(right, bottom)
        const topRight = new Point(right, top)
        const bottomLeft = new Point(left, bottom)

        const sides = [
          new LineSegment(topLeft, topRight),
          new LineSegment(topRight, bottomRight),
          new LineSegment(bottomRight, bottomLeft),
          new LineSegment(bottomLeft, topLeft)
        ];
        
        let intersections = []
        for (const side of sides) {
          const side_intersections = this.intersectLineSegment(side);
          intersections = [...intersections, ...side_intersections]
        }
        return intersections;
      }



      
    }
    
    
    function P(x,y){return new Point(x,y)}
    function V(x,y){return new Vector(x,y)}
    
    //  wrapping it in parentheses to avoid the pitfalls of automatic semicolon insertion.
    
    class Draggable extends React.Component{
      constructor(props){
        super(props);
        this.state = {
          isDragging: false,
          // x:50,y:50,
          prevX: 0,
          prevY: 0
        }
      }
      
      handleMouseDown(event){
        this.setState({
          isDragging: true,
          prevX: event.clientX,
          prevY: event.clientY
        })
        
        window.addEventListener("mousemove", (e)=>this.handleMouseMove(e));
        window.addEventListener("mouseup", (e)=>this.handleMouseUp(e));
        event.preventDefault(); // prevent text selection when dragging
      }
      
      handleMouseUp(event){
        this.setState({"isDragging": false})
      }
      
      handleMouseMove(event){
        if (this.state.isDragging) { 
          const mx = event.clientX; 
          const my = event.clientY; 
          const dx = mx-this.state.prevX;
          const dy = my-this.state.prevY;
          this.setState({
            prevX: mx,
            prevY: my,
            // x: this.state.x+dx,
            // y: this.state.y+dy
          })
          this.props.onDrag(dx, dy);
        }
      }
      
      render(){
        return (
        <g className="draggable" onMouseDown={(e)=>this.handleMouseDown(e)} >
          <g>
            {this.props.children}
          </g>
        </g>
        )
      }  
    }
    
    function App(){
      const [shapes, setShapes] = React.useState([
        new Circle(P(200, 120), 50),
        new Circle(P(320, 350), 100),
        new Circle(P(120, 380), 80),
        new Rectangle(P(200,200), 200,200)
      ]);
      
      const [lights, setLights] = React.useState([
      P(20,110)
      ])
      
      // shot rays from light sources
      const count = 10;
      const angles = Array.from({length:count},(v,k)=>k/count*Math.PI*2)
      console.log(angles)
      const rays = lights.map((light_pos)=>{
        return angles.map((a)=>{
          const x = Math.cos(a);
          const y = Math.sin(a);
          const dir = V(x,y);
          return new Ray(light_pos, dir.normalized(1000))
        })
      }).flat(1)
      
      
      
      function raytrace(rays, shapes){
        // find intersections
        let intersections = []
        let secondaries = []
        for(let primary of rays)
        {
          if(primary == null){
            secondaries = [...secondaries, ...[null]]
            continue;
          }

          let ray_intersections = [];
          for(let shape of shapes)
          {
            if(shape instanceof Circle){
              const shape_intersections = primary.intersectCircle(shape);
              ray_intersections = [...ray_intersections, ...shape_intersections];
            } else if(shape instanceof Rectangle){
              const shape_intersections = primary.intersectRectangle(shape);
              ray_intersections = [...ray_intersections, ...shape_intersections];
            } 

          }
          
          if(ray_intersections.length>0)
          {
            // find closest interseciont
            let closest = ray_intersections.reduce((a, b) => primary.origin.distance(a.origin) < primary.origin.distance(b.origin) ? a : b);
            ray_intersections.push(closest)
            
            // reflect ray on intersection
            const reflected_rays = [closest].map((i)=>{
              const secondary_dir = primary.direction.reflect(i.direction)
              return new Ray(i.origin, secondary_dir.normalized(100));
            });
            
            secondaries = [...secondaries, ...reflected_rays]
          }else[
            secondaries = [...secondaries, ...[null]]
          ]
        }
        
        // intersections
        return [secondaries, intersections];
      }
      
      
      
      function move_light(light, dx, dy){
        const i = lights.indexOf(light);
        let new_lights = lights.map((l)=>light.copy());
        new_lights[i].x+=dx
        new_lights[i].y+=dy;
        console.log(new_lights)
        setLights(new_lights);
      }
      
      function move_shape(shape, dx, dy){
        const i = shapes.indexOf(shape);
        let new_shapes = shapes.map((s)=>s.copy());
        new_shapes[i].center.x+=dx
        new_shapes[i].center.y+=dy;
        console.log(new_shapes)
        setShapes(new_shapes);
      }

      function pointsToSvgPath(points) {
        let path = "M" + points.map(p => `${p.x},${p.y}`).join(" L");
        return path;
      }
      
      // const intesections = intersect(rays, shapes)
      let paths = rays.map((ray)=>[ray.origin])
      let current_rays = [...rays];
      let all_rays = [...current_rays]
      for(let i=0; i<2; i++){
        let [secondary, intersections] = raytrace(current_rays, shapes);
        for(let k=0; k<secondary.length; k++){
          if(secondary[k]!=null){
            let p = secondary[k].origin
            paths[k].push(p)
          }
        }
        current_rays = secondary;
        all_rays = [...all_rays, ...secondary]
      }
      all_rays = all_rays.filter((ray)=>ray != null);
      console.log("paths", paths)
      // let [secondary, intersections] = raytrace(rays, shapes);
      // let [thirdsteps, thirdintersections] = raytrace(secondary, shapes);
      // let all_rays = [...rays, ...secondary]
      // let all_rays = raytrace(rays, shapes);
      // console.log("hit points", hitpoints)
      // const all_rays = [...rays, ...secondary, ...thirdsteps];

      const colors = ["blueviolet", "darkorchid", "lightpink", "mediumslateblue", "mediumslateblue"]

      return (
      <div>
        <section>
          <h3>Lights</h3>
          <ul>
            {lights.map(light => (
              <li>{light.x}, {light.y}</li>
              ))}
            </ul>
          </section>
          <svg width="512" height="512" style={{backgroundColor: "blueviolet"}}>

            <g className="circles">
              {shapes.filter(shape=>shape instanceof Circle).map(shape => (
                <Draggable onDrag={(dx, dy)=>move_shape(shape, dx, dy)}>
                  <circle cx={shape.center.x} cy={shape.center.y} r={shape.radius} fill="lightgrey" stroke="black"></circle>
                </Draggable>
                ))}
              </g>

              <g className="rectangles">
              {shapes.filter(shape=>shape instanceof Rectangle).map(shape => (
                <Draggable onDrag={(dx, dy)=>move_shape(shape, dx, dy)}>
                  <rect x={shape.center.x-shape.width/2}
                        y={shape.center.y-shape.height/2}
                        width={shape.width}
                        height={shape.height}
                        rx="5"
                        ry="5"
                        fill="rgba(255,255,255,0.1)" 
                        stroke="black"></rect>
                </Draggable>
                ))}
              </g>
              
              <g className="rays" style={{display: "none"}}>
                {all_rays.map(ray => (
                  <g>
                    <line x1={ray.origin.x} 
                    y1={ray.origin.y} 
                    x2={ray.origin.x+ray.direction.x*1}
                    y2={ray.origin.y+ray.direction.y*1}
                    stroke="orange"
                    >
                  </line>
                </g>
                ))}
              </g>

              <g className="paths">
                {paths.filter(path=>path.length>1).map((points) => (
                  <g>
                    <path d={pointsToSvgPath(points)}
                          stroke="orange" fill="none">
                    </path>
                  </g>
                ))}
              </g>
              
              <g className="lights"> 
                {lights.map(light => (
                  <Draggable onDrag={(dx, dy)=>move_light(light, dx, dy)}>
                    <circle cx={light.x} cy={light.y} r="10" fill="yellow" stroke="orange"></circle>
                  </Draggable>
                  ))}
                </g>
              </svg>
            </div>
            );
          }
        </script>
        <script type="text/babel">
          const rdom = ReactDOM.createRoot(document.getElementById('root'))
          rdom.render(React.createElement(App));
        </script>
      </body>
      
      </html>